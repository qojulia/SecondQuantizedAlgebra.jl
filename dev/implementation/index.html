<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Implementation · SecondQuantizedAlgebra.jl</title><meta name="title" content="Implementation · SecondQuantizedAlgebra.jl"/><meta property="og:title" content="Implementation · SecondQuantizedAlgebra.jl"/><meta property="twitter:title" content="Implementation · SecondQuantizedAlgebra.jl"/><meta name="description" content="Documentation for SecondQuantizedAlgebra.jl."/><meta property="og:description" content="Documentation for SecondQuantizedAlgebra.jl."/><meta property="twitter:description" content="Documentation for SecondQuantizedAlgebra.jl."/><meta property="og:url" content="https://qojulia.github.io/SecondQuantizedAlgebra.jl/implementation/"/><meta property="twitter:url" content="https://qojulia.github.io/SecondQuantizedAlgebra.jl/implementation/"/><link rel="canonical" href="https://qojulia.github.io/SecondQuantizedAlgebra.jl/implementation/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">SecondQuantizedAlgebra.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../API/">API</a></li><li class="is-active"><a class="tocitem" href>Implementation</a><ul class="internal"><li><a class="tocitem" href="#Hilbert-spaces"><span>Hilbert spaces</span></a></li><li><a class="tocitem" href="#Operators-(a.k.a.-*q*-numbers)"><span>Operators (a.k.a. <em>q</em>-numbers)</span></a></li><li><a class="tocitem" href="#Symbolic-parameters-(a.k.a.-*c*-numbers)"><span>Symbolic parameters (a.k.a. <em>c</em>-numbers)</span></a></li><li><a class="tocitem" href="#Operator-expressions-and-commutation-relations"><span>Operator expressions and commutation relations</span></a></li><li><a class="tocitem" href="#interface"><span>The <em>q</em>-number interface</span></a></li></ul></li><li><a class="tocitem" href="../symbolic_sums/">Symbolic Sums and Indices</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Implementation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Implementation</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/qojulia/SecondQuantizedAlgebra.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/qojulia/SecondQuantizedAlgebra.jl/blob/main/docs/src/implementation.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Implementation"><a class="docs-heading-anchor" href="#Implementation">Implementation</a><a id="Implementation-1"></a><a class="docs-heading-anchor-permalink" href="#Implementation" title="Permalink"></a></h1><p>Let&#39;s take a closer look at each step involved from defining a system to arriving at a numerical solution of the underlying time dynamics.</p><h2 id="Hilbert-spaces"><a class="docs-heading-anchor" href="#Hilbert-spaces">Hilbert spaces</a><a id="Hilbert-spaces-1"></a><a class="docs-heading-anchor-permalink" href="#Hilbert-spaces" title="Permalink"></a></h2><p>The first step in treating a system with <strong>SecondQuantizedAlgebra.jl</strong> is to specify the Hilbert space on which the system is defined. There are two types of Hilbert spaces implemented, namely <a href="../API/#SecondQuantizedAlgebra.FockSpace"><code>FockSpace</code></a> and <a href="../API/#SecondQuantizedAlgebra.NLevelSpace"><code>NLevelSpace</code></a>. The first describes systems whose operators follow the fundamental bosonic commutation relations (such as the quantum harmonic oscillator), whereas the latter describes systems consisting of a finite number of energy levels with an arbitrary energy difference in between (such as atoms).</p><p>A <a href="../API/#SecondQuantizedAlgebra.FockSpace"><code>FockSpace</code></a> simply needs a name in order to be defined:</p><pre><code class="language-julia hljs">hf = FockSpace(:fock1)</code></pre><p><a href="../API/#SecondQuantizedAlgebra.NLevelSpace"><code>NLevelSpace</code></a> requires a name as well as labels for the energy levels. For example</p><pre><code class="language-julia hljs">h_atom = NLevelSpace(:atom, (:g,:e))</code></pre><p>defines an <a href="../API/#SecondQuantizedAlgebra.NLevelSpace"><code>NLevelSpace</code></a> with the name <code>:atom</code> and the two levels labeled by <code>:g</code> and <code>:e</code>, respectively. Note that the levels can be labeled by (almost) anything. For example, <code>NLevelSpace(:two_level, (1,2))</code> would define a Hilbert space describing a system with the two discrete energy levels labeled by <code>1</code> and <code>2</code>. Specifically for numbers, there is also the short-hand method to write <code>NLevelSpace(:five_level, 5)</code> which creates a system with levels <code>1:5</code>. Note that by default the first level in the list of all levels is designated as the ground state. This can be changed by specifying the ground state explicitly as a third argument to <a href="../API/#SecondQuantizedAlgebra.NLevelSpace"><code>NLevelSpace</code></a>, e.g. <code>NLevelSpace(:four_level, 4, 2)</code> would designate the state <code>2</code> as the ground state. The ground state projector will be eliminated during simplification (see below).</p><p>Composite systems are generally described by a <a href="../API/#SecondQuantizedAlgebra.ProductSpace"><code>ProductSpace</code></a>, i.e. a Hilbert space that consists of multiple subspaces. Each subspace is either a <a href="../API/#SecondQuantizedAlgebra.FockSpace"><code>FockSpace</code></a> or an <a href="../API/#SecondQuantizedAlgebra.NLevelSpace"><code>NLevelSpace</code></a>. They can be created using the <a href="../API/#QuantumInterface.tensor"><code>tensor</code></a> function or the unicode symbol <a href="../API/#QuantumInterface.:⊗"><code>⊗</code></a> [\otimes]. For example</p><pre><code class="language-julia hljs">h_prod1 = tensor(hf, h_atom)
h_prod2 = tensor(h_prod1, NLevelSpace(:three_level, 3))
h_prod3 = tensor(hf, h_atom, NLevelSpace(:three_level, 3)) # == h_prod2</code></pre><p>creates two product spaces. The first, <code>h_prod1</code>, consists of the previously defined <code>FockSpace(:fock1)</code> and <code>NLevelSpace(:atom, (:g,:e))</code>. The second one, <code>h_prod2</code>, adds in another <code>NLevelSpace(:three_level, 3)</code>. In principle arbitrarily many systems can be combined this way.</p><h2 id="Operators-(a.k.a.-*q*-numbers)"><a class="docs-heading-anchor" href="#Operators-(a.k.a.-*q*-numbers)">Operators (a.k.a. <em>q</em>-numbers)</a><a id="Operators-(a.k.a.-*q*-numbers)-1"></a><a class="docs-heading-anchor-permalink" href="#Operators-(a.k.a.-*q*-numbers)" title="Permalink"></a></h2><p>Once the Hilbert space of the system has been defined, we can proceed by defining operators, or <em>q</em>-numbers, on them. They are the fundamental building blocks of symbolic expressions in <strong>SecondQuantizedAlgebra.jl</strong>. Again, there are essentially two kinds of operators implemented: the quantum harmonic destruction operator <a href="../API/#SecondQuantizedAlgebra.Destroy"><code>Destroy</code></a> which acts on a <a href="../API/#SecondQuantizedAlgebra.FockSpace"><code>FockSpace</code></a>, as well as a <a href="../API/#SecondQuantizedAlgebra.Transition"><code>Transition</code></a> operator which describes a transition between any two levels on an <a href="../API/#SecondQuantizedAlgebra.NLevelSpace"><code>NLevelSpace</code></a>. These operators can only be defined on the corresponding Hilbert spaces. Note that there is no intrinsic reason that prevents us from implementing more types of operators (<a href="#interface">see below</a>), there was simply no need to do that so far.</p><p>Here are a few examples:</p><pre><code class="language-julia hljs">hf = FockSpace(:fock)
a = Destroy(hf, :a)

h_atom = NLevelSpace(:atom,(:g,:e))
σge = Transition(h_atom, :σ, :g, :e)
σ = Transition(h_atom, :σ)
@assert isequal(σge, σ(:g,:e)) # true</code></pre><p>As you can see, the destruction operator <a href="../API/#SecondQuantizedAlgebra.Destroy"><code>Destroy</code></a> is created on a <a href="../API/#SecondQuantizedAlgebra.FockSpace"><code>FockSpace</code></a> and given a name. The transition operator, however, additionally requires you to specify the levels between which it describes the transition. Defining a transition without levels specified creates a callable instance which needs to be called with valid level labels before one can actually use it in any algebraic expressions. Note that in Bra-Ket notation, the transition operator <code>Transition(h, i, j)</code> is simply <span>$|i\rangle \langle j|$</span>. Also, the bosonic creation operator is simply given by the <code>adjoint</code> of <a href="../API/#SecondQuantizedAlgebra.Destroy"><code>Destroy</code></a>.</p><p>These fundamental operators are all of subtypes of <a href="../API/#SecondQuantizedAlgebra.QSym"><code>QSym</code></a>, and constitute the basic symbolic building blocks for the noncommutative algebra used in <strong>SecondQuantizedAlgebra.jl</strong>. They can be combined using standard algebraic functions.</p><pre><code class="language-julia hljs">ex_fock = 0.1*a&#39;*a
ex_trans = im*(σ(:g,:e) - σ(:e,:g))</code></pre><p>Note that only operators that are defined on the same Hilbert space can be algebraically combined. The resulting expressions are stored as <a href="../API/#SecondQuantizedAlgebra.QTerm"><code>QTerm</code></a> types.</p><p>In composite systems, we also need to specify on which subsystem the respective operator acts. This information is important as operators acting on different subsystems commute with one another, but operators acting on the same one do not. When multiplying together operators in a composite systems, they are automatically ordered according to the order of Hilbert spaces. It&#39;s specified by an additional argument when creating operators.</p><pre><code class="language-julia hljs">h_prod = FockSpace(:fock1) ⊗ FockSpace(:fock2)
a = Destroy(h_prod,:a,1)
b = Destroy(h_prod,:b,2)
a*b # a*b
b*a # a*b
a&#39;*b*a # a&#39;*a*b</code></pre><p>If a subspace occurs only once in a <a href="../API/#SecondQuantizedAlgebra.ProductSpace"><code>ProductSpace</code></a>, the choice on which an operator acts is unique and can therefore be omitted on construction.</p><pre><code class="language-julia hljs">h_prod = FockSpace(:fock1) ⊗ FockSpace(:fock2) ⊗ NLevelSpace(:atom,(:g,:e))
σ = Transition(h_prod, :σ) # no need to specify acts_on</code></pre><p>For convenience, there is also a macro that can be used to construct operators:</p><pre><code class="language-julia hljs">h = FockSpace(:fock) ⊗ NLevelSpace(:two_level, 2)
@qnumbers a::Destroy(h) σ::Transition(h)
ex = a&#39;*σ(1,2) + a*σ(2,1)</code></pre><h2 id="Symbolic-parameters-(a.k.a.-*c*-numbers)"><a class="docs-heading-anchor" href="#Symbolic-parameters-(a.k.a.-*c*-numbers)">Symbolic parameters (a.k.a. <em>c</em>-numbers)</a><a id="Symbolic-parameters-(a.k.a.-*c*-numbers)-1"></a><a class="docs-heading-anchor-permalink" href="#Symbolic-parameters-(a.k.a.-*c*-numbers)" title="Permalink"></a></h2><p>Commutative numbers (<em>c</em>-numbers) are represented by <code>SymbolicUtils.Sym</code> from the <a href="https://github.com/JuliaSymbolics/SymbolicUtils.jl"><strong>SymbolicUtils.jl</strong></a> package and a custom subtype to <code>Number</code> called <a href="../API/#SecondQuantizedAlgebra.CNumber"><code>CNumber</code></a>. They are generally assumed to be complex numbers and can be defined with the <a href="../API/#SecondQuantizedAlgebra.cnumbers"><code>cnumbers</code></a> function or the corresponding macro <a href="../API/#SecondQuantizedAlgebra.@cnumbers"><code>@cnumbers</code></a>. You can use them together with <em>q</em>-numbers to build symbolic expressions describing the Hamiltonian, e.g.</p><pre><code class="language-julia hljs">h = FockSpace(:fock)
@cnumbers ω η
@qnumbers a::Destroy(h)
H = ω*a&#39;*a + η*(a + a&#39;)</code></pre><p>Real numbers (<em>r</em>-numbers) are similar to <em>c</em>-numbers, except that they are their own complex conjugate. They can be defined with the <a href="../API/#SecondQuantizedAlgebra.rnumbers"><code>rnumbers</code></a> function or the corresponding macro <a href="../API/#SecondQuantizedAlgebra.@rnumbers"><code>@rnumbers</code></a>. </p><pre><code class="language-julia hljs">@rnumbers ω η
ω&#39; # ω
exp(1im*η)*(exp(1im*η))&#39; # 1</code></pre><h2 id="Operator-expressions-and-commutation-relations"><a class="docs-heading-anchor" href="#Operator-expressions-and-commutation-relations">Operator expressions and commutation relations</a><a id="Operator-expressions-and-commutation-relations-1"></a><a class="docs-heading-anchor-permalink" href="#Operator-expressions-and-commutation-relations" title="Permalink"></a></h2><p>The equations of motion of <em>q</em>-numbers are determined by evaluating commutators. This can be done by using fundamental commutation relations, which are immediately applied whenever operators are combined in an algebraic expression.</p><p>For the quantum harmonic oscillator destruction operator <span>$a$</span>, we have the canonical commutator</p><p class="math-container">\[[a,a^\dagger] = 1.\]</p><p>Within the framework, we choose normal ordering, which surmounts to the rewriting rule</p><p class="math-container">\[a a^\dagger ~\Rightarrow~ a^\dagger a +1.\]</p><p>For transition operators <span>$\sigma^{ij}$</span> denoting a transition from level <span>$j$</span> to level <span>$i$</span>, on the other hand, we have a rule for products,</p><p class="math-container">\[\sigma^{ij}\sigma^{kl} ~\Rightarrow~ \delta_{jk}\sigma^{il},\]</p><p>which is implemented as rewriting rule just so. Additionally, we use the fact that in a system with levels <span>$\{1,...,n\}$</span></p><p class="math-container">\[\sum_{j=1}^n \sigma^{jj} = 1\]</p><p>in order to eliminate the projector on the ground state. This reduces the amount of equations required for each <a href="../API/#SecondQuantizedAlgebra.NLevelSpace"><code>NLevelSpace</code></a> by 1. Note that, as mentioned before, the ground state is by default chosen to be the first (but this can be changed). Hence, the default rewriting rule to eliminate the ground-state projector is</p><p class="math-container">\[\sigma^{11} ~\Rightarrow~ 1 - \sum_{j=2}^n \sigma^{jj}.\]</p><p>Any expression involving operators is stored as a <a href="../API/#SecondQuantizedAlgebra.QTerm"><code>QTerm</code></a> type. The expression trees are structured such that the application of commutation relations can be done efficiently. There are two concrete subtypes of <a href="../API/#SecondQuantizedAlgebra.QTerm"><code>QTerm</code></a>, namely <code>QMul</code> representing a multiplication and <code>QAdd</code> representing an addition. Methods of multiplication and addition are implemented such that <code>QSym &lt; QMul &lt; QAdd</code>, i.e. a multiplication can only consist of numbers and fundamental operators (it cannot contain another multiplication or addition) and <code>QAdd</code> is always at the highest level possibly containing numbers, <code>QSym</code>s and <code>QMul</code>s (but no other <code>QAdd</code>s). This makes it easy and efficient to recurse through the expression tree and find pairs of operators that should be rewritten according to some commutation relation.</p><p>Note that only simplification using commutation relations is implemented directly in <strong>SecondQuantizedAlgebra.jl</strong>. For any other simplification routines, operators are averaged (without applying a cumulant expansion) which makes them numbers. Those numbers are stored as expressions in <a href="https://github.com/JuliaSymbolics/SymbolicUtils.jl"><strong>SymbolicUtils.jl</strong></a> and simplified according to standard simplification rules. Afterwards, they can be converted back into <a href="../API/#SecondQuantizedAlgebra.QTerm"><code>QTerm</code></a> expressions.</p><h4 id="Mapping-levels-for-NLevelSpace"><a class="docs-heading-anchor" href="#Mapping-levels-for-NLevelSpace">Mapping levels for <code>NLevelSpace</code></a><a id="Mapping-levels-for-NLevelSpace-1"></a><a class="docs-heading-anchor-permalink" href="#Mapping-levels-for-NLevelSpace" title="Permalink"></a></h4><p>The conversion to a numeric representation between <a href="../API/#SecondQuantizedAlgebra.FockSpace"><code>FockSpace</code></a> and <code>FockBasis</code> is always uniquely defined. However, there is some freedom of choice when it comes to <a href="../API/#SecondQuantizedAlgebra.NLevelSpace"><code>NLevelSpace</code></a> and the equivalent of <code>NLevelBasis</code>, specifically when using symbolic levels. While it is clear that a symbolic <a href="../API/#SecondQuantizedAlgebra.Transition"><code>Transition</code></a> operator should map to a numeric <code>transition</code>, the choice of which level represents maps to which basis state in the <code>NLevelBasis</code> is not fixed.</p><p>When using numeric level representations, the <a href="../API/#SecondQuantizedAlgebra.to_numeric"><code>to_numeric</code></a> methods default to using the same numbered basis state:</p><pre><code class="language-julia hljs">using SecondQuantizedAlgebra, QuantumOpticsBase
h = NLevelSpace(:TwoLevelAtom, (1, 2))
b = NLevelBasis(2)
s = Transition(h, :s, 1, 2)
@assert to_numeric(s, b) == transition(b, 1, 2)</code></pre><p>The order here can be overridden using the <code>level_map</code> keyword. When using symbolic levels, the <code>level_map</code> keyword is required.</p><pre><code class="language-julia hljs">using SecondQuantizedAlgebra, QuantumOpticsBase
h = NLevelSpace(:TwoLevelAtom, (:g, :e))
b = NLevelBasis(2)
s = Transition(h, :s, :g, :e)
level_map = Dict(:g =&gt; 1, :e =&gt; 2)
@assert to_numeric(s, b; level_map=level_map) == transition(b, 1, 2)</code></pre><h4 id="Numeric-averages-and-conversion"><a class="docs-heading-anchor" href="#Numeric-averages-and-conversion">Numeric averages and conversion</a><a id="Numeric-averages-and-conversion-1"></a><a class="docs-heading-anchor-permalink" href="#Numeric-averages-and-conversion" title="Permalink"></a></h4><p>While the examples so far were relatively simple and would have been easy to calculate by hand, things quickly become more difficult whenever product spaces and higher-order products are involved.</p><p>Behind the scenes, we use the <a href="../API/#SecondQuantizedAlgebra.numeric_average"><code>numeric_average</code></a> method in order to compute the numeric expectation value for the given operators and states. This method in turn calls into the numeric conversion <a href="../API/#SecondQuantizedAlgebra.to_numeric"><code>to_numeric</code></a> and then uses <code>QuantumOpticsBase.expect</code> on the result in order to calculate the respective expectation values for the given state and operators numerically. Should you need to compute numerical averages from a symbolic one for a given numerical state you can also call <a href="../API/#SecondQuantizedAlgebra.numeric_average"><code>numeric_average</code></a> directly.</p><pre><code class="language-julia hljs">using SecondQuantizedAlgebra, QuantumOpticsBase
hfock = FockSpace(:cavity)
hnlevel = NLevelSpace(:ThreeLevelAtom, (:a, :b, :c))
h = hfock ⊗ hnlevel
a = Destroy(h, :a)
s = Transition(h, :s, :a, :c)
levelmap = Dict(
    :a =&gt; 3,
    :b =&gt; 2,
    :c =&gt; 1,
)

bfock = FockBasis(10)
bnlevel = NLevelBasis(3)
psi = coherentstate(bfock, 0.3) ⊗ (nlevelstate(bnlevel, 1) + nlevelstate(bnlevel, 3)) / sqrt(2)

avg = average(a&#39; * s)
avg_num = numeric_average(avg, psi; level_map=levelmap)</code></pre><p>Similarly, you can also just obtain the numerical representation of an operator by directly calling <a href="../API/#SecondQuantizedAlgebra.to_numeric"><code>to_numeric</code></a> and a given basis.</p><pre><code class="language-julia hljs">b = bfock ⊗ bnlevel
a_num = to_numeric(a, b)</code></pre><p>Note that <a href="../API/#SecondQuantizedAlgebra.to_numeric"><code>to_numeric</code></a> returns a <code>SparseOperator</code> for single operators, but a <code>LazyTensor</code> operator whenever a product space is involved. Lazy evaluation of tensor products is incredibly useful here, as symbolically easy to treat systems can become quite large numerically.</p><p>When a large number of Hilbert spaces is involved, it can even become tricky to store a single <code>Ket</code>. In order to overcome this limitation, QuantumOpticsBase also offers lazy evaluation of state products, allowing you to compute expectation values and initial states for very large product states.</p><pre><code class="language-julia hljs">psi_lazy = LazyKet(b, (coherentstate(bfock, 0.3), (nlevelstate(bnlevel, 1) + nlevelstate(bnlevel, 3)) / sqrt(2)),)
avg_num_lazy = numeric_average(avg, psi_lazy; level_map=levelmap)
@assert isapprox(avg_num, avg_num_lazy)</code></pre><h2 id="interface"><a class="docs-heading-anchor" href="#interface">The <em>q</em>-number interface</a><a id="interface-1"></a><a class="docs-heading-anchor-permalink" href="#interface" title="Permalink"></a></h2><p>While there are currently only two different Hilbert spaces and two different types of fundamental operators implemented, their implementations are somewhat generic. This means that one can implement custom operator types along with some commutation relations for rewriting. The requirements for that are:</p><ul><li>Custom operator types need to be subtypes of <a href="../API/#SecondQuantizedAlgebra.QSym"><code>QSym</code></a>.</li><li><code>Base.:*(::Operator1, ::Operator2)</code>: A multiplication method that rewrites according to a commutation relation has to be implemented.</li><li><code>SecondQuantizedAlgebra.ismergeable(::Operator1, ::Operator2) = true</code> is required so pairs of <code>Operator1</code> and <code>Operator2</code> are detected in longer expressions and rewritten according to their commutation relation.</li><li>Optional: custom Hilbert space type matching the new operators.</li></ul><h4 id="Example:-Harmonic-oscillator-quadratures"><a class="docs-heading-anchor" href="#Example:-Harmonic-oscillator-quadratures">Example: Harmonic oscillator quadratures</a><a id="Example:-Harmonic-oscillator-quadratures-1"></a><a class="docs-heading-anchor-permalink" href="#Example:-Harmonic-oscillator-quadratures" title="Permalink"></a></h4><p>To illustrate, say we would like to implement the quantum harmonic oscillator in terms of the position operator <span>$x$</span> and the momentum operator <span>$p$</span> rather than the ladder operators. They fulfill the commutation relation</p><p class="math-container">\[[x,p] = i\]</p><p>and we will use it to rewrite occurrences of <span>$xp \Rightarrow px + i$</span>. For simplicity, we will define them on a <a href="../API/#SecondQuantizedAlgebra.FockSpace"><code>FockSpace</code></a> instead of defining a custom Hilbert space as well.</p><pre><code class="language-julia hljs">using SecondQuantizedAlgebra

struct Position &lt;: QSym
    hilbert
    name
    aon
    metadata
end
Position(hilbert, name, aon; metadata=SecondQuantizedAlgebra.source_metadata(:Position, name)) =
    Position(hilbert, name, aon, metadata)

struct Momentum &lt;: QSym
    hilbert
    name
    aon
    metadata
end
Momentum(hilbert, name, aon; metadata=SecondQuantizedAlgebra.source_metadata(:Momentum, name)) =
    Momentum(hilbert, name, aon, metadata)</code></pre><p>Note that any subtype to <a href="../API/#SecondQuantizedAlgebra.QSym"><code>QSym</code></a> needs to have the four fields shown above, and the  associated outer constructor. The outer constructor is needed for the interface to  Symbolics.jl. More fields could be added, but the four shown here are always required.  Now, for methods we simply need:</p><pre><code class="language-julia hljs">SecondQuantizedAlgebra.ismergeable(::Position,::Momentum) = true
Base.:*(x::Position, p::Momentum) = im + p*x
Base.isequal(a::Position, b::Position) = isequal(a.hilbert, b.hilbert) &amp;&amp; isequal(a.name, b.name) &amp;&amp; isequal(a.aon, b.aon)
Base.isequal(a::Momentum, b::Momentum) = isequal(a.hilbert, b.hilbert) &amp;&amp; isequal(a.name, b.name) &amp;&amp; isequal(a.aon, b.aon)</code></pre><p>The <code>Base.isequal</code> methods do not compare metadata fields. Note that if your subtypes of  <a href="../API/#SecondQuantizedAlgebra.QSym"><code>QSym</code></a> have type parameters, you must also implement a method of <code>Base.hash</code> such  that <code>isequal(x,y)</code> implies <code>hash(x) == hash(y)</code>.</p><p>We can now use our new operator types in expressions and derive equations of motion for them.</p><pre><code class="language-julia hljs">h = FockSpace(:oscillator)
x = Position(h,:x,1)
p = Momentum(h,:p,1)

@cnumbers ω m
H = p^2/(2m) + 0.5m*ω^2*x^2</code></pre><p class="math-container">\[\frac{1}{2 m} p p + 0.5 m \omega^{2} x x\]</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../API/">« API</a><a class="docs-footer-nextpage" href="../symbolic_sums/">Symbolic Sums and Indices »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.17.0 on <span class="colophon-date" title="Monday 23 February 2026 15:47">Monday 23 February 2026</span>. Using Julia version 1.10.10.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
