var documenterSearchIndex = {"docs":
[{"location":"symbolic_sums/#Symbolic-Sums-and-Indices","page":"Symbolic Sums and Indices","title":"Symbolic Sums and Indices","text":"","category":"section"},{"location":"symbolic_sums/","page":"Symbolic Sums and Indices","title":"Symbolic Sums and Indices","text":"Many physical systems contain multiple elements of the same kind, which basically do the same thing just with different rates. For these systems it is convenient to describe the Hamiltonian and the dissipative processes with indexed objects and sums. A well-known example is the Tavis-Cummings Hamiltonian, which describes the interaction of N two-level atoms with a cavity mode according to the Hamiltonian","category":"page"},{"location":"symbolic_sums/","page":"Symbolic Sums and Indices","title":"Symbolic Sums and Indices","text":"beginequation\nH_mathrmTC = omega_c a^ a + sum_i^N omega_i sigma_i^22 + sum_i^N g_i (a^dagger sigma_i^12 + a sigma_i^21)\nendequation","category":"page"},{"location":"symbolic_sums/","page":"Symbolic Sums and Indices","title":"Symbolic Sums and Indices","text":"In principle we can write down and derive the equations for all N atoms explicitly, but this can take a long time for large N. The more practical and elegant approach is to derive the equations for averages of indexed operators and insert all possible number combinations afterwards. The implementation of symbolic sums and indices allows for exactly this.","category":"page"},{"location":"symbolic_sums/#Implementation","page":"Symbolic Sums and Indices","title":"Implementation","text":"","category":"section"},{"location":"symbolic_sums/#Index","page":"Symbolic Sums and Indices","title":"Index","text":"","category":"section"},{"location":"symbolic_sums/","page":"Symbolic Sums and Indices","title":"Symbolic Sums and Indices","text":"The main tool to use symbolic summations is the Index object. This object has four different fields, which all need to be specified upon construction. These fields consist of the full HilbertSpace h, a name, which is just a generic symbol, a range, which can either consist of again a symbol or a concrete number, and a specific Hilbert space aon, which defines the space on which operators, that inherit the Index entity, act on. This means that an Index for a NLevelSpace can only be used by Transition operators. In the example below, two indices are defined equivalently, as well as a third one being defined acting on the FockSpace of the defined ProductSpace h.","category":"page"},{"location":"symbolic_sums/","page":"Symbolic Sums and Indices","title":"Symbolic Sums and Indices","text":"using SecondQuantizedAlgebra\n\n@cnumbers N\n\nha = NLevelSpace(:atoms,2)\nhc = FockSpace(:cavity)\nh = hc ⊗ ha\n\ni = Index(h,:i,N,ha)\ni2 = Index(h,:i,N,2) #equivalent definition\n\nn = Index(h,:n,5,hc)","category":"page"},{"location":"symbolic_sums/#IndexedOperators","page":"Symbolic Sums and Indices","title":"IndexedOperators","text":"","category":"section"},{"location":"symbolic_sums/","page":"Symbolic Sums and Indices","title":"Symbolic Sums and Indices","text":"Operators, such as Destroy or Transition can be associated with an Index of the corresponding Hilbert space by creating a so-called IndexedOperator. This object consists of two fields, namely the operator itself and an Index. Below, there are two IndexedOperator entities created on the two different Hilbert spaces defined previously.","category":"page"},{"location":"symbolic_sums/","page":"Symbolic Sums and Indices","title":"Symbolic Sums and Indices","text":"σ(x,y,z) = IndexedOperator(Transition(h,:σ,x,y),z)\na(z) = IndexedOperator(Destroy(h,:a),z)","category":"page"},{"location":"symbolic_sums/","page":"Symbolic Sums and Indices","title":"Symbolic Sums and Indices","text":"In the above example, we defined both indexed operators σ and a as callable instances with the attribute-variable z. These can now be used to easily create operators, that act specifically with their associated index.","category":"page"},{"location":"symbolic_sums/","page":"Symbolic Sums and Indices","title":"Symbolic Sums and Indices","text":"a(n)*σ(2,2,i)\nnothing #hide","category":"page"},{"location":"symbolic_sums/","page":"Symbolic Sums and Indices","title":"Symbolic Sums and Indices","text":"a_n sigma_i^22","category":"page"},{"location":"symbolic_sums/","page":"Symbolic Sums and Indices","title":"Symbolic Sums and Indices","text":"Similar to operators, one can also create so-called IndexedVariable objects, which consist simply of a name and an index.","category":"page"},{"location":"symbolic_sums/","page":"Symbolic Sums and Indices","title":"Symbolic Sums and Indices","text":"gi = IndexedVariable(:g,i)\nnothing #hide","category":"page"},{"location":"symbolic_sums/","page":"Symbolic Sums and Indices","title":"Symbolic Sums and Indices","text":"g_i","category":"page"},{"location":"symbolic_sums/#Summations","page":"Symbolic Sums and Indices","title":"Summations","text":"","category":"section"},{"location":"symbolic_sums/","page":"Symbolic Sums and Indices","title":"Symbolic Sums and Indices","text":"As for now, we only created single instances of indexed operators. These operators and variables can now be used to define symbolic summations, which can then again be used in defining a Hamiltonian and deriving equations of motion for specific operator averages. Such a summation needs two arguments to be constructed, the term, over which the summation shall sum over, and an Index, over which the sum runs. As an example, we define below a simple sum over a single indexed operator.","category":"page"},{"location":"symbolic_sums/","page":"Symbolic Sums and Indices","title":"Symbolic Sums and Indices","text":"∑(σ(2,2,i),i)\nnothing #hide","category":"page"},{"location":"symbolic_sums/","page":"Symbolic Sums and Indices","title":"Symbolic Sums and Indices","text":"undersetioversetNsum σ_i^22","category":"page"},{"location":"symbolic_sums/","page":"Symbolic Sums and Indices","title":"Symbolic Sums and Indices","text":"As can be seen above, a sum with a single running-index can be created using the ∑ (\\sum) command. Other equivalent functions are Σ (\\Pauli) and the SingleSum() constructor. These constructors can also take a third optional argument specifying a set of indices, which are non equivalent to the summation index.","category":"page"},{"location":"symbolic_sums/","page":"Symbolic Sums and Indices","title":"Symbolic Sums and Indices","text":"j = Index(h,:j,N,2)\n∑(σ(2,2,i),i,[j])\nnothing #hide","category":"page"},{"location":"symbolic_sums/","page":"Symbolic Sums and Indices","title":"Symbolic Sums and Indices","text":"underseti j oversetNsum σ_i^22","category":"page"},{"location":"symbolic_sums/","page":"Symbolic Sums and Indices","title":"Symbolic Sums and Indices","text":"Similar to this one can also create summations over up to two different running-indices:","category":"page"},{"location":"symbolic_sums/","page":"Symbolic Sums and Indices","title":"Symbolic Sums and Indices","text":"∑(a(n)*σ(2,1,i),i,n)\nnothing #hide","category":"page"},{"location":"symbolic_sums/","page":"Symbolic Sums and Indices","title":"Symbolic Sums and Indices","text":"undersetioversetNsum undersetnoverset5sum a_n  σ_i^21","category":"page"},{"location":"symbolic_sums/","page":"Symbolic Sums and Indices","title":"Symbolic Sums and Indices","text":"These two running-indices do not need to act on different Hilbert spaces. In particular, for indices acting on the same Hilbert space, a simplification occurs, as shown below.","category":"page"},{"location":"symbolic_sums/","page":"Symbolic Sums and Indices","title":"Symbolic Sums and Indices","text":"k = Index(h,:k,N,ha)\nl = Index(h,:l,N,ha)\n\n∑(σ(2,1,k)*σ(1,2,l),k,l)\nnothing #hide","category":"page"},{"location":"symbolic_sums/","page":"Symbolic Sums and Indices","title":"Symbolic Sums and Indices","text":"undersetkneloversetNsum undersetlnekoversetNsum sigma_l^12  sigma_k^21 + undersetkoversetNsum sigma_k^22","category":"page"},{"location":"symbolic_sums/","page":"Symbolic Sums and Indices","title":"Symbolic Sums and Indices","text":"If two indices, acting on the same Hilbert space, meet inside of a sum, the special case, where the numeric values of both indices are the same, i.e l=k, is calculated immediately. This can also be observed, when a symbolic sum is multiplied with an IndexedOperator that is acting on the same Hilbert space as the summation-index.","category":"page"},{"location":"symbolic_sums/","page":"Symbolic Sums and Indices","title":"Symbolic Sums and Indices","text":"∑(σ(2,2,k),k) * σ(2,1,l)\nnothing #hide","category":"page"},{"location":"symbolic_sums/","page":"Symbolic Sums and Indices","title":"Symbolic Sums and Indices","text":"undersetkneloversetNsum sigma_k^22  sigma_l^21 + sigma_l^21","category":"page"},{"location":"symbolic_sums/#Short-Example","page":"Symbolic Sums and Indices","title":"Short Example","text":"","category":"section"},{"location":"symbolic_sums/","page":"Symbolic Sums and Indices","title":"Symbolic Sums and Indices","text":"We will briefly go over the entire process of defining a Hamiltonian. For this example we will consider N 2-level atoms in a single mode cavity.","category":"page"},{"location":"symbolic_sums/","page":"Symbolic Sums and Indices","title":"Symbolic Sums and Indices","text":"using SecondQuantizedAlgebra\n\nha = NLevelSpace(:atoms,2)\nhc = FockSpace(:cavity)\nh = hc ⊗ ha\n\n@cnumbers N Δ κ γ ν\n\ni = Index(h,:i,N,ha)\nj = Index(h,:j,N,ha)\n\n@qnumbers b::Destroy(h)\nσ(x,y,z) = IndexedOperator(Transition(h,:σ,x,y),z)\ngi = IndexedVariable(:g,i)\n\nH = Δ*b'*b + ∑(gi*(b*σ(2,1,i) + b'*σ(1,2,i)),i)\nnothing #hide","category":"page"},{"location":"symbolic_sums/","page":"Symbolic Sums and Indices","title":"Symbolic Sums and Indices","text":"undersetioversetNsum g_i  b  sigma_i^21 + undersetioversetNsum g_i  b^dagger  sigma_i^12 + Delta b^dagger b","category":"page"},{"location":"#SecondQuantizedAlgebra","page":"Home","title":"SecondQuantizedAlgebra","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: docs) (Image: codecov) (Image: Benchmarks)","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: Code Style: Blue) (Image: Aqua QA) (Image: jet)","category":"page"},{"location":"","page":"Home","title":"Home","text":"A Julia package for symbolic manipulation and algebraic computation with second quantized operators. SecondQuantizedAlgebra.jl provides a flexible framework for working with creation and annihilation operators, commutation relations, and algebraic expressions common in quantum many-body theory and quantum optics.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The package provides:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Symbolic representation of bosonic fock creation and annihilation operators\nAutomatic (anti-)commutation relation handling\nAlgebraic simplification and normal ordering\nSupport for atom and spin operators\nExtensible for custom operator types","category":"page"},{"location":"","page":"Home","title":"Home","text":"The code was refactored out of QuantumCumulants.jl.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Install with Julia's package manager:","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add SecondQuantizedAlgebra","category":"page"},{"location":"#Usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using SecondQuantizedAlgebra\nusing SymbolicUtils\n\nha = NLevelSpace(:atoms,2)\nhc = FockSpace(:cavity)\nh = hc ⊗ ha\n\n@qnumbers b::Destroy(h)\nσ(i,j) = Transition(h,:σ,i,j)\n\n@cnumbers g Δ\n\nH = Δ*b'*b + g*(b*σ(2,1) + b'*σ(1,2))\n\n@show b*b'\n@show σ(2,1)*σ(1,1)\n\nsimplify(commutator(H, b))","category":"page"},{"location":"","page":"Home","title":"Home","text":"See the documentation for more details and advanced usage.","category":"page"},{"location":"#Contributing","page":"Home","title":"Contributing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Contributions and suggestions are welcome! Please open issues or pull requests on GitHub.","category":"page"},{"location":"#License","page":"Home","title":"License","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This project is licensed under the MIT License.","category":"page"},{"location":"implementation/#Implementation","page":"Implementation","title":"Implementation","text":"","category":"section"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"Let's take a closer look at each step involved from defining a system to arriving at a numerical solution of the underlying time dynamics.","category":"page"},{"location":"implementation/#Hilbert-spaces","page":"Implementation","title":"Hilbert spaces","text":"","category":"section"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"The first step in treating a system with SecondQuantizedAlgebra.jl is to specify the Hilbert space on which the system is defined. There are two types of Hilbert spaces implemented, namely FockSpace and NLevelSpace. The first describes systems whose operators follow the fundamental bosonic commutation relations (such as the quantum harmonic oscillator), whereas the latter describes systems consisting of a finite number of energy levels with an arbitrary energy difference in between (such as atoms).","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"A FockSpace simply needs a name in order to be defined:","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"using SecondQuantizedAlgebra # hide\nhf = FockSpace(:fock1)\nnothing # hide","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"NLevelSpace requires a name as well as labels for the energy levels. For example","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"h_atom = NLevelSpace(:atom, (:g,:e))\nnothing # hide","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"defines an NLevelSpace with the name :atom and the two levels labeled by :g and :e, respectively. Note that the levels can be labeled by (almost) anything. For example, NLevelSpace(:two_level, (1,2)) would define a Hilbert space describing a system with the two discrete energy levels labeled by 1 and 2. Specifically for numbers, there is also the short-hand method to write NLevelSpace(:five_level, 5) which creates a system with levels 1:5. Note that by default the first level in the list of all levels is designated as the ground state. This can be changed by specifying the ground state explicitly as a third argument to NLevelSpace, e.g. NLevelSpace(:four_level, 4, 2) would designate the state 2 as the ground state. The ground state projector will be eliminated during simplification (see below).","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"Composite systems are generally described by a ProductSpace, i.e. a Hilbert space that consists of multiple subspaces. Each subspace is either a FockSpace or an NLevelSpace. They can be created using the tensor function or the unicode symbol ⊗ [\\otimes]. For example","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"h_prod1 = tensor(hf, h_atom)\nh_prod2 = tensor(h_prod1, NLevelSpace(:three_level, 3))\nh_prod3 = tensor(hf, h_atom, NLevelSpace(:three_level, 3)) # == h_prod2\nnothing # hide","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"creates two product spaces. The first, h_prod1, consists of the previously defined FockSpace(:fock1) and NLevelSpace(:atom, (:g,:e)). The second one, h_prod2, adds in another NLevelSpace(:three_level, 3). In principle arbitrarily many systems can be combined this way.","category":"page"},{"location":"implementation/#Operators-(a.k.a.-*q*-numbers)","page":"Implementation","title":"Operators (a.k.a. q-numbers)","text":"","category":"section"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"Once the Hilbert space of the system has been defined, we can proceed by defining operators, or q-numbers, on them. They are the fundamental building blocks of symbolic expressions in SecondQuantizedAlgebra.jl. Again, there are essentially two kinds of operators implemented: the quantum harmonic destruction operator Destroy which acts on a FockSpace, as well as a Transition operator which describes a transition between any two levels on an NLevelSpace. These operators can only be defined on the corresponding Hilbert spaces. Note that there is no intrinsic reason that prevents us from implementing more types of operators (see below), there was simply no need to do that so far.","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"Here are a few examples:","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"using SecondQuantizedAlgebra # hide\nhf = FockSpace(:fock)\na = Destroy(hf, :a)\n\nh_atom = NLevelSpace(:atom,(:g,:e))\nσge = Transition(h_atom, :σ, :g, :e)\nσ = Transition(h_atom, :σ)\n@assert isequal(σge, σ(:g,:e)) # true\nnothing # hide","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"As you can see, the destruction operator Destroy is created on a FockSpace and given a name. The transition operator, however, additionally requires you to specify the levels between which it describes the transition. Defining a transition without levels specified creates a callable instance which needs to be called with valid level labels before one can actually use it in any algebraic expressions. Note that in Bra-Ket notation, the transition operator Transition(h, i, j) is simply irangle langle j. Also, the bosonic creation operator is simply given by the adjoint of Destroy.","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"These fundamental operators are all of subtypes of QSym, and constitute the basic symbolic building blocks for the noncommutative algebra used in SecondQuantizedAlgebra.jl. They can be combined using standard algebraic functions.","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"ex_fock = 0.1*a'*a\nex_trans = im*(σ(:g,:e) - σ(:e,:g))\nnothing # hide","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"Note that only operators that are defined on the same Hilbert space can be algebraically combined. The resulting expressions are stored as QTerm types.","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"In composite systems, we also need to specify on which subsystem the respective operator acts. This information is important as operators acting on different subsystems commute with one another, but operators acting on the same one do not. When multiplying together operators in a composite systems, they are automatically ordered according to the order of Hilbert spaces. It's specified by an additional argument when creating operators.","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"h_prod = FockSpace(:fock1) ⊗ FockSpace(:fock2)\na = Destroy(h_prod,:a,1)\nb = Destroy(h_prod,:b,2)\na*b # a*b\nb*a # a*b\na'*b*a # a'*a*b\nnothing # hide","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"If a subspace occurs only once in a ProductSpace, the choice on which an operator acts is unique and can therefore be omitted on construction.","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"h_prod = FockSpace(:fock1) ⊗ FockSpace(:fock2) ⊗ NLevelSpace(:atom,(:g,:e))\nσ = Transition(h_prod, :σ) # no need to specify acts_on\nnothing # hide","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"For convenience, there is also a macro that can be used to construct operators:","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"h = FockSpace(:fock) ⊗ NLevelSpace(:two_level, 2)\n@qnumbers a::Destroy(h) σ::Transition(h)\nex = a'*σ(1,2) + a*σ(2,1)\nnothing # hide","category":"page"},{"location":"implementation/#Symbolic-parameters-(a.k.a.-*c*-numbers)","page":"Implementation","title":"Symbolic parameters (a.k.a. c-numbers)","text":"","category":"section"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"Commutative numbers (c-numbers) are represented by SymbolicUtils.Sym from the SymbolicUtils.jl package and a custom subtype to Number called CNumber. They are generally assumed to be complex numbers and can be defined with the cnumbers function or the corresponding macro @cnumbers. You can use them together with q-numbers to build symbolic expressions describing the Hamiltonian, e.g.","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"using SecondQuantizedAlgebra # hide\nh = FockSpace(:fock)\n@cnumbers ω η\n@qnumbers a::Destroy(h)\nH = ω*a'*a + η*(a + a')\nnothing # hide","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"Real numbers (r-numbers) are similar to c-numbers, except that they are their own complex conjugate. They can be defined with the rnumbers function or the corresponding macro @rnumbers. ","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"using SecondQuantizedAlgebra # hide\n@rnumbers ω η\nω' # ω \nexp(1im*η)*(exp(1im*η))' # 1\nnothing # hide","category":"page"},{"location":"implementation/#Operator-expressions-and-commutation-relations","page":"Implementation","title":"Operator expressions and commutation relations","text":"","category":"section"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"The equations of motion of q-numbers are determined by evaluating commutators. This can be done by using fundamental commutation relations, which are immediately applied whenever operators are combined in an algebraic expression.","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"For the quantum harmonic oscillator destruction operator a, we have the canonical commutator","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"aa^dagger = 1","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"Within the framework, we choose normal ordering, which surmounts to the rewriting rule","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"a a^dagger Rightarrow a^dagger a +1","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"For transition operators sigma^ij denoting a transition from level j to level i, on the other hand, we have a rule for products,","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"sigma^ijsigma^kl Rightarrow delta_jksigma^il","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"which is implemented as rewriting rule just so. Additionally, we use the fact that in a system with levels 1n","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"sum_j=1^n sigma^jj = 1","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"in order to eliminate the projector on the ground state. This reduces the amount of equations required for each NLevelSpace by 1. Note that, as mentioned before, the ground state is by default chosen to be the first (but this can be changed). Hence, the default rewriting rule to eliminate the ground-state projector is","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"sigma^11 Rightarrow 1 - sum_j=2^n sigma^jj","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"Any expression involving operators is stored as a QTerm type. The expression trees are structured such that the application of commutation relations can be done efficiently. There are two concrete subtypes of QTerm, namely QMul representing a multiplication and QAdd representing an addition. Methods of multiplication and addition are implemented such that QSym < QMul < QAdd, i.e. a multiplication can only consist of numbers and fundamental operators (it cannot contain another multiplication or addition) and QAdd is always at the highest level possibly containing numbers, QSyms and QMuls (but no other QAdds). This makes it easy and efficient to recurse through the expression tree and find pairs of operators that should be rewritten according to some commutation relation.","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"Note that only simplification using commutation relations is implemented directly in SecondQuantizedAlgebra.jl. For any other simplification routines, operators are averaged (without applying a cumulant expansion) which makes them numbers. Those numbers are stored as expressions in SymbolicUtils.jl and simplified according to standard simplification rules. Afterwards, they can be converted back into QTerm expressions.","category":"page"},{"location":"implementation/#Mapping-levels-for-NLevelSpace","page":"Implementation","title":"Mapping levels for NLevelSpace","text":"","category":"section"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"The conversion to a numeric representation between FockSpace and FockBasis is always uniquely defined. However, there is some freedom of choice when it comes to NLevelSpace and the equivalent of NLevelBasis, specifically when using symbolic levels. While it is clear that a symbolic Transition operator should map to a numeric transition, the choice of which level represents maps to which basis state in the NLevelBasis is not fixed.","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"When using numeric level representations, the to_numeric methods default to using the same numbered basis state:","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"using SecondQuantizedAlgebra, QuantumOpticsBase\nh = NLevelSpace(:TwoLevelAtom, (1, 2))\nb = NLevelBasis(2)\ns = Transition(h, :s, 1, 2)\n@assert to_numeric(s, b) == transition(b, 1, 2)\nnothing # hide","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"The order here can be overridden using the level_map keyword. When using symbolic levels, the level_map keyword is required.","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"using SecondQuantizedAlgebra, QuantumOpticsBase\nh = NLevelSpace(:TwoLevelAtom, (:g, :e))\nb = NLevelBasis(2)\ns = Transition(h, :s, :g, :e)\nlevel_map = Dict(:g => 1, :e => 2)\n@assert to_numeric(s, b; level_map=level_map) == transition(b, 1, 2)\nnothing # hide","category":"page"},{"location":"implementation/#Numeric-averages-and-conversion","page":"Implementation","title":"Numeric averages and conversion","text":"","category":"section"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"While the examples so far were relatively simple and would have been easy to calculate by hand, things quickly become more difficult whenever product spaces and higher-order products are involved.","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"Behind the scenes, we use the numeric_average method in order to compute the numeric expectation value for the given operators and states. This method in turn calls into the numeric conversion to_numeric and then uses QuantumOpticsBase.expect on the result in order to calculate the respective expectation values for the given state and operators numerically. Should you need to compute numerical averages from a symbolic one for a given numerical state you can also call numeric_average directly.","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"using SecondQuantizedAlgebra, QuantumOpticsBase\nhfock = FockSpace(:cavity)\nhnlevel = NLevelSpace(:ThreeLevelAtom, (:a, :b, :c))\nh = hfock ⊗ hnlevel\na = Destroy(h, :a)\ns = Transition(h, :s, :a, :c)\nlevelmap = Dict(\n    :a => 3,\n    :b => 2,\n    :c => 1,\n)\n\nbfock = FockBasis(10)\nbnlevel = NLevelBasis(3)\npsi = coherentstate(bfock, 0.3) ⊗ (nlevelstate(bnlevel, 1) + nlevelstate(bnlevel, 3)) / sqrt(2)\n\navg = average(a' * s)\navg_num = numeric_average(avg, psi; level_map=levelmap)\nnothing # hide","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"Similarly, you can also just obtain the numerical representation of an operator by directly calling to_numeric and a given basis.","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"b = bfock ⊗ bnlevel\na_num = to_numeric(a, b)\nnothing # hide","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"Note that to_numeric returns a SparseOperator for single operators, but a LazyTensor operator whenever a product space is involved. Lazy evaluation of tensor products is incredibly useful here, as symbolically easy to treat systems can become quite large numerically.","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"When a large number of Hilbert spaces is involved, it can even become tricky to store a single Ket. In order to overcome this limitation, QuantumOpticsBase also offers lazy evaluation of state products, allowing you to compute expectation values and initial states for very large product states.","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"psi_lazy = LazyKet(b, (coherentstate(bfock, 0.3), (nlevelstate(bnlevel, 1) + nlevelstate(bnlevel, 3)) / sqrt(2)),)\navg_num_lazy = numeric_average(avg, psi_lazy; level_map=levelmap)\n@assert isapprox(avg_num, avg_num_lazy)","category":"page"},{"location":"implementation/#interface","page":"Implementation","title":"The q-number interface","text":"","category":"section"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"While there are currently only two different Hilbert spaces and two different types of fundamental operators implemented, their implementations are somewhat generic. This means that one can implement custom operator types along with some commutation relations for rewriting. The requirements for that are:","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"Custom operator types need to be subtypes of QSym.\nBase.:*(::Operator1, ::Operator2): A multiplication method that rewrites according to a commutation relation has to be implemented.\nSecondQuantizedAlgebra.ismergeable(::Operator1, ::Operator2) = true is required so pairs of Operator1 and Operator2 are detected in longer expressions and rewritten according to their commutation relation.\nOptional: custom Hilbert space type matching the new operators.","category":"page"},{"location":"implementation/#Example:-Harmonic-oscillator-quadratures","page":"Implementation","title":"Example: Harmonic oscillator quadratures","text":"","category":"section"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"To illustrate, say we would like to implement the quantum harmonic oscillator in terms of the position operator x and the momentum operator p rather than the ladder operators. They fulfill the commutation relation","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"xp = i","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"and we will use it to rewrite occurrences of xp Rightarrow px + i. For simplicity, we will define them on a FockSpace instead of defining a custom Hilbert space as well.","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"using Latexify # hide\nset_default(double_linebreak=true) # hide\nusing SecondQuantizedAlgebra\n\nstruct Position <: QSym\n    hilbert\n    name\n    aon\n    metadata\nend\nPosition(hilbert, name, aon; metadata=SecondQuantizedAlgebra.source_metadata(:Position, name)) =\n    Position(hilbert, name, aon, metadata)\n\nstruct Momentum <: QSym\n    hilbert\n    name\n    aon\n    metadata\nend\nMomentum(hilbert, name, aon; metadata=SecondQuantizedAlgebra.source_metadata(:Momentum, name)) =\n    Momentum(hilbert, name, aon, metadata)\nnothing # hide","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"Note that any subtype to QSym needs to have the four fields shown above, and the  associated outer constructor. The outer constructor is needed for the interface to  Symbolics.jl. More fields could be added, but the four shown here are always required.  Now, for methods we simply need:","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"SecondQuantizedAlgebra.ismergeable(::Position,::Momentum) = true\nBase.:*(x::Position, p::Momentum) = im + p*x\nBase.isequal(a::Position, b::Position) = isequal(a.hilbert, b.hilbert) && isequal(a.name, b.name) && isequal(a.aon, b.aon)\nBase.isequal(a::Momentum, b::Momentum) = isequal(a.hilbert, b.hilbert) && isequal(a.name, b.name) && isequal(a.aon, b.aon)","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"The Base.isequal methods do not compare metadata fields. Note that if your subtypes of  QSym have type parameters, you must also implement a method of Base.hash such  that isequal(x,y) implies hash(x) == hash(y).","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"We can now use our new operator types in expressions and derive equations of motion for them.","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"h = FockSpace(:oscillator)\nx = Position(h,:x,1)\np = Momentum(h,:p,1)\n\n@cnumbers ω m\nH = p^2/(2m) + 0.5m*ω^2*x^2","category":"page"},{"location":"API/#API","page":"API","title":"API","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"Pages = [\"API.md\"]\nDepth = 2:3","category":"page"},{"location":"API/#API:-Hilbert-Spaces","page":"API","title":"Hilbert Spaces","text":"","category":"section"},{"location":"API/#SecondQuantizedAlgebra.HilbertSpace","page":"API","title":"SecondQuantizedAlgebra.HilbertSpace","text":"HilbertSpace\n\nAbstract type for representing Hilbert spaces.\n\n\n\n\n\n","category":"type"},{"location":"API/#SecondQuantizedAlgebra.ProductSpace","page":"API","title":"SecondQuantizedAlgebra.ProductSpace","text":"ProductSpace <: HilbertSpace\n\nStores a composite HilbertSpace consisting of multiple subspaces. Generally created by computing the tensor product ⊗ of subspaces.\n\n\n\n\n\n","category":"type"},{"location":"API/#SecondQuantizedAlgebra.FockSpace","page":"API","title":"SecondQuantizedAlgebra.FockSpace","text":"FockSpace <: HilbertSpace\n\nHilbertSpace defining a Fock space for bosonic operators. See also: Destroy, Create\n\n\n\n\n\n","category":"type"},{"location":"API/#SecondQuantizedAlgebra.NLevelSpace","page":"API","title":"SecondQuantizedAlgebra.NLevelSpace","text":"NLevelSpace <: HilbertSpace\nNLevelSpace(name::Symbol,levels,GS=levels[1])\n\nDefine a HilbertSpace for an object consisting of N discrete energy levels. The given levels must be an integer specifying the number of levels, or an iterable collection of levels. The argument GS specifies which state should be treated as ground state and is rewritten using population conservation during simplification. See also: Transition\n\nExamples:\n\njulia> ha = NLevelSpace(:a,3)\nℋ(a)\n\njulia> ha = NLevelSpace(:a,(:g,:e))\nℋ(a)\n\n\n\n\n\n","category":"type"},{"location":"API/#SecondQuantizedAlgebra.ClusterSpace","page":"API","title":"SecondQuantizedAlgebra.ClusterSpace","text":"ClusterSpace <: HilbertSpace\nClusterSpace(original_space,N,order)\n\nA Hilbert space representing N identical copies of another Hilbert space, with correlations up to a specified order.\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumInterface.:⊗","page":"API","title":"QuantumInterface.:⊗","text":"⊗(spaces::HilbertSpace...)\n\nCreate a ProductSpace consisting of multiple subspaces. Unicode \\otimes<tab> alias of tensor\n\nExamples\n\njulia> hf = FockSpace(:f)\nℋ(f)\n\njulia> ha = NLevelSpace(:a,2)\nℋ(a)\n\njulia> h = hf⊗ha\nℋ(f) ⊗ ℋ(a)\n\n\n\n\n\n","category":"function"},{"location":"API/#QuantumInterface.tensor","page":"API","title":"QuantumInterface.tensor","text":"tensor(spaces::HilbertSpace...)\n\nCreate a ProductSpace consisting of multiple subspaces. See also ⊗.\n\n\n\n\n\n","category":"function"},{"location":"API/#SecondQuantizedAlgebra.PauliSpace","page":"API","title":"SecondQuantizedAlgebra.PauliSpace","text":"PauliSpace <: HilbertSpace\n\nHilbertSpace defining a Spin space for two-level atom Pauli operators. See also: Pauli, Create\n\n\n\n\n\n","category":"type"},{"location":"API/#SecondQuantizedAlgebra.Pauli","page":"API","title":"SecondQuantizedAlgebra.Pauli","text":"Pauli <: QSym\n\nPauli operator on a PauliSpace representing the Pauli operators σx, σy and σz for two-level spin systems. The field axis represents x, y and z as 1, 2 and 3, respectively. The used rewriting rule is σj⋅σk → δjk + i⋅ϵjkl⋅σl.\n\nExamples\n\njulia> h = PauliSpace(\"Spin-1/2\")\nℋ(Spin-1/2)\n\njulia> σx = Pauli(h,:σ,1)\nσx\n\n\n\n\n\n","category":"type"},{"location":"API/#SecondQuantizedAlgebra.SpinSpace","page":"API","title":"SecondQuantizedAlgebra.SpinSpace","text":"SpinSpace <: HilbertSpace\n\nHilbertSpace defining a Spin space for N > 1 identical two-level atom operators. See also: Spin, Create\n\n\n\n\n\n","category":"type"},{"location":"API/#SecondQuantizedAlgebra.Spin","page":"API","title":"SecondQuantizedAlgebra.Spin","text":"Spin <: QSym\n\nSpin operator on a SpinSpace representing the Spin-operators Sx, Sy and Sz for collective spin systems. The field axis represents x, y and z as 1, 2 and 3, respectively. The operators follow the rules for angular momentum operators: [Sj,Sk] = i⋅∑ϵjkl⋅Sl\n\nExamples\n\njulia> h = SpinSpace(\"Spin-N/2\")\nℋ(Spin-N/2)\n\njulia> Sx = Spin(h,:S,1)\nSx\n\n\n\n\n\n","category":"type"},{"location":"API/#API:-Operators","page":"API","title":"q-Numbers","text":"","category":"section"},{"location":"API/#SecondQuantizedAlgebra.QSym","page":"API","title":"SecondQuantizedAlgebra.QSym","text":"QSym <: QNumber\n\nAbstract type representing fundamental operator types.\n\n\n\n\n\n","category":"type"},{"location":"API/#SecondQuantizedAlgebra.QTerm","page":"API","title":"SecondQuantizedAlgebra.QTerm","text":"QTerm <: QNumber\n\nAbstract type representing noncommutative expressions.\n\n\n\n\n\n","category":"type"},{"location":"API/#SecondQuantizedAlgebra.@qnumbers","page":"API","title":"SecondQuantizedAlgebra.@qnumbers","text":"@qnumbers\n\nConvenience macro for the construction of operators.\n\nExamples\n\njulia> h = FockSpace(:fock)\nℋ(fock)\n\njulia> @qnumbers a::Destroy(h)\n(a,)\n\njulia> h = FockSpace(:one) ⊗ FockSpace(:two)\nℋ(one) ⊗ ℋ(two)\n\njulia> @qnumbers b::Destroy(h,2)\n(b,)\n\n\n\n\n\n","category":"macro"},{"location":"API/#SecondQuantizedAlgebra.Destroy","page":"API","title":"SecondQuantizedAlgebra.Destroy","text":"Destroy <: QSym\n\nBosonic operator on a FockSpace representing the quantum harmonic oscillator annihilation operator.\n\n\n\n\n\n","category":"type"},{"location":"API/#SecondQuantizedAlgebra.Create","page":"API","title":"SecondQuantizedAlgebra.Create","text":"Create <: QSym\n\nBosonic operator on a FockSpace representing the quantum harmonic oscillator creation operator.\n\n\n\n\n\n","category":"type"},{"location":"API/#SecondQuantizedAlgebra.Transition","page":"API","title":"SecondQuantizedAlgebra.Transition","text":"Transition <: QSym\nTransition(h::NLevelSpace,name::Symbol,i,j)\n\nFundamental operator defining a transition from level j to level i on a NLevelSpace. The notation corresponds to Dirac notation, i.e. the above is equivalent to |i⟩⟨j|.\n\nExamples\n\njulia> ha = NLevelSpace(:a,(:g,:e))\nℋ(a)\n\njulia> σ = Transition(ha,:σ,:g,:e)\nσge\n\n\n\n\n\n","category":"type"},{"location":"API/#API:-Symbolic-numbers","page":"API","title":"Symbolic Numbers","text":"","category":"section"},{"location":"API/#SecondQuantizedAlgebra.CNumber","page":"API","title":"SecondQuantizedAlgebra.CNumber","text":"CNumber <: Number\n\nAbstract type for all symbolic numbers, i.e. Parameter, average.\n\n\n\n\n\n","category":"type"},{"location":"API/#SecondQuantizedAlgebra.Parameter","page":"API","title":"SecondQuantizedAlgebra.Parameter","text":"Parameter <: CNumber\n\nType used as symbolic type in a SymbolicUtils.Sym variable to represent a parameter.\n\n\n\n\n\n","category":"type"},{"location":"API/#SecondQuantizedAlgebra.cnumbers","page":"API","title":"SecondQuantizedAlgebra.cnumbers","text":"cnumbers(symbols::Symbol...)\ncnumbers(s::String)\n\nCreate symbolic cnumbers.\n\nExpamples\n\njulia> ps = cnumbers(:a, :b)\n(a, b)\n\njulia> cnumbers(\"a b\") == ps\ntrue\n\n\n\n\n\n","category":"function"},{"location":"API/#SecondQuantizedAlgebra.cnumber","page":"API","title":"SecondQuantizedAlgebra.cnumber","text":"cnumber(symbols::Symbol)\ncnumber(s::String)\n\nCreate symbolic cnumber.\n\nExpamples\n\njulia> ps = cnumber(:a)\na\n\njulia> cnumber(\"a\") == ps\ntrue\n\n\n\n\n\n","category":"function"},{"location":"API/#SecondQuantizedAlgebra.@cnumbers","page":"API","title":"SecondQuantizedAlgebra.@cnumbers","text":"@cnumbers(ps...)\n\nConvenience macro to quickly define symbolic cnumbers.\n\nExamples\n\njulia> @cnumbers ω κ\n(ω, κ)\n\n\n\n\n\n","category":"macro"},{"location":"API/#SecondQuantizedAlgebra.RNumber","page":"API","title":"SecondQuantizedAlgebra.RNumber","text":"RNumber <: Real\n\nAbstract type for real symbolic numbers RealParameter.\n\n\n\n\n\n","category":"type"},{"location":"API/#SecondQuantizedAlgebra.RealParameter","page":"API","title":"SecondQuantizedAlgebra.RealParameter","text":"RealParameter <: RNumber\n\nType used as symbolic type in a SymbolicUtils.Sym variable to represent a real parameter.\n\n\n\n\n\n","category":"type"},{"location":"API/#SecondQuantizedAlgebra.rnumbers","page":"API","title":"SecondQuantizedAlgebra.rnumbers","text":"rnumbers(symbols::Symbol...)\nrnumbers(s::String)\n\nCreate symbolic rnumbers.\n\nExpamples\n\njulia> ps = rnumbers(:a, :b)\n(a, b)\n\njulia> rnumbers(\"a b\") == ps\ntrue\n\n\n\n\n\n","category":"function"},{"location":"API/#SecondQuantizedAlgebra.rnumber","page":"API","title":"SecondQuantizedAlgebra.rnumber","text":"rnumber(symbols::Symbol)\nrnumber(s::String)\n\nCreate symbolic rnumber.\n\nExpamples\n\njulia> ps = rnumber(:a)\na\n\njulia> rnumber(\"a\") == ps\ntrue\n\n\n\n\n\n","category":"function"},{"location":"API/#SecondQuantizedAlgebra.@rnumbers","page":"API","title":"SecondQuantizedAlgebra.@rnumbers","text":"@rnumbers(ps...)\n\nConvenience macro to quickly define symbolic rnumbers.\n\nExamples\n\njulia> @rnumbers ω κ\n(ω, κ)\n\n\n\n\n\n","category":"macro"},{"location":"API/#API:-Average","page":"API","title":"Average","text":"","category":"section"},{"location":"API/#SecondQuantizedAlgebra.average","page":"API","title":"SecondQuantizedAlgebra.average","text":"average(::QNumber)\n\nCompute the average of an operator.\n\n\n\n\n\n","category":"function"},{"location":"API/#API:-Utils","page":"API","title":"Utility functions","text":"","category":"section"},{"location":"API/#SecondQuantizedAlgebra.commutator","page":"API","title":"SecondQuantizedAlgebra.commutator","text":"commutator(a,b)\n\nComputes the commutator a*b - b*a.\n\n\n\n\n\n","category":"function"},{"location":"API/#SecondQuantizedAlgebra.acts_on","page":"API","title":"SecondQuantizedAlgebra.acts_on","text":"acts_on(op)\n\nShows on which Hilbert space op acts. For QSym types, this returns an Integer, whereas for a Term it returns a Vector{Int} whose entries specify all subspaces on which the expression acts.\n\n\n\n\n\n","category":"function"},{"location":"API/#SecondQuantizedAlgebra.find_operators","page":"API","title":"SecondQuantizedAlgebra.find_operators","text":"find_operators(::HilbertSpace, order; names=nothing)\n\nFind all operators that fully define a system up to the given order.\n\n\n\n\n\n","category":"function"},{"location":"API/#SecondQuantizedAlgebra.unique_ops","page":"API","title":"SecondQuantizedAlgebra.unique_ops","text":"unique_ops(ops)\n\nFor a given list of operators, return only unique ones taking into account their adjoints.\n\n\n\n\n\n","category":"function"},{"location":"API/#SecondQuantizedAlgebra.unique_ops!","page":"API","title":"SecondQuantizedAlgebra.unique_ops!","text":"unique_ops!(ops)\n\nIn-place version of unique_ops.\n\n\n\n\n\n","category":"function"},{"location":"API/#SecondQuantizedAlgebra.fundamental_operators","page":"API","title":"SecondQuantizedAlgebra.fundamental_operators","text":"fundamental_operators(::HilbertSpace)\n\nReturn all fundamental operators for a given Hilbertspace. For example, a FockSpace only has one fundamental operator, Destroy.\n\n\n\n\n\n","category":"function"},{"location":"API/#SecondQuantizedAlgebra.transition_superscript","page":"API","title":"SecondQuantizedAlgebra.transition_superscript","text":"transition_superscript(::Bool)\n\nSpecify whether the indices in a Transition operator should be printed as superscript. Default is true. If set to false, the indices corresponding to the levels are printed as subscript.\n\n\n\n\n\n","category":"function"},{"location":"API/#SecondQuantizedAlgebra.to_numeric","page":"API","title":"SecondQuantizedAlgebra.to_numeric","text":"to_numeric(q::QNumber, b::QuantumOpticsBase.Basis; level_map = nothing)\nto_numeric(q::QNumber, state; level_map = nothing)\n\nConvert a symbolic operator q to its equivalent numeric (matrix) form on the basis b. The optional argument level_map can be set to a dictionary that specifies how to map levels of a Transition to the ones given in an NLevelBasis. Note: If the levels of a transition are symbolic, setting level_map is required.\n\nSee also: numeric_average\n\nExamples\n\njulia> to_numeric(Destroy(FockSpace(:fock), :a), FockBasis(10)) Operator(dim=11x11)   basis: Fock(cutoff=10)[...]\n\n\n\n\n\nto_numeric(q::QNumber, b::QuantumOpticsBase.Basis, d::Dict)\nto_numeric(q::QNumber, state, d::Dict)\n\nMap a symbolic operator q to a numeric (matrix) defined in the  dictionary d. See also: numeric_average\n\n\n\n\n\n","category":"function"},{"location":"API/#SecondQuantizedAlgebra.numeric_average","page":"API","title":"SecondQuantizedAlgebra.numeric_average","text":"numeric_average(avg::Average, state; level_map = nothing)\nnumeric_average(q::QNumber, state; level_map = nothing)\n\nFrom a symbolic average avg or operator q, compute the corresponding numerical average value with the given quantum state state. This state can either be of type QuantumOpticsBase.StateVector or QuantumOpticsBase.Operator.\n\nSee also: to_numeric\n\n\n\n\n\nnumeric_average(avg::Average, state, d::Dict)\nnumeric_average(q::QNumber, state, d::Dict)\n\nFrom a symbolic average avg or operator q, map the operator defined in  the dictionary d and compute the numerical average value for an with the  given quantum state state. This state can either be of type  QuantumOpticsBase.StateVector or QuantumOpticsBase.Operator.\n\nSee also: to_numeric\n\n\n\n\n\n","category":"function"},{"location":"API/#API:-Sums","page":"API","title":"Symbolic Summations","text":"","category":"section"},{"location":"API/#SecondQuantizedAlgebra.Index","page":"API","title":"SecondQuantizedAlgebra.Index","text":"Index(hilb::HilbertSpace,name::Symbol,range::Union{Int64,Sym},aon::Int)\n\nDefines an index, using a Symbol as a name, and a HilbertSpace for computation and commutator-relations. Indices with all same fields will be considered equal. See also: IndexedOperator and IndexedVariable\n\nFields:\n\nhilb: The whole HilbertSpace, the index will be defined on.\nname: A Symbol, which defines the name of the index, and how product-terms of IndexedOperator are ordered (alphabetical)\nrange: The upper bound limit of the index. This can be a SymbolicUitls.Symbolic or any Number.\naon: Number specifying the specific HilbertSpace, where the Index acts on.\n\n\n\n\n\n","category":"type"},{"location":"API/#SecondQuantizedAlgebra.IndexedOperator","page":"API","title":"SecondQuantizedAlgebra.IndexedOperator","text":"IndexedOperator <: QSym\nIndexedOperator(op::Union{Transition,Create,Destroy},ind::Index)\n\nOperator, associated with an index.\n\nFields:\n\nop: Operator, either a Transition, a Destroy or a Create can be defined.\nind: The index, the operator will be associated with.\n\n\n\n\n\n","category":"type"},{"location":"API/#SecondQuantizedAlgebra.IndexedVariable","page":"API","title":"SecondQuantizedAlgebra.IndexedVariable","text":"IndexedVariable <: CNumber\nIndexedVariable(name::Symbol,ind::Index)\nIndexedVariable(name::Symbol,ind1::Index,ind2:Index)\n\nA indexed symbolic variable. The variable can (once equations are calculated) be easily exchanged for numerical values. Calling a IndexedVariable using two different Index objects one can create DoubleIndexedVariable objects.\n\n\n\n\n\n","category":"type"},{"location":"API/#SecondQuantizedAlgebra.DoubleIndexedVariable","page":"API","title":"SecondQuantizedAlgebra.DoubleIndexedVariable","text":"DoubleIndexedVariable <: CNumber\nDoubleIndexedVariable(name::Symbol,ind1::Index,ind2::Index;identical::Bool)\n\nA double-indexed symbolic variable. The variable can (once equations are calculated) be easily exchanged for numerical values.\n\nFields:\n\nname: A Symbol, defining the name of the variable\nind1: The first Index of the variable\nind2: The second Index of the variable\nidentical: A Bool, defining if the variable can have non-zero main-diagonal terms, e.g: Γᵢᵢ ≠ 0 would be specified with true.\n\n\n\n\n\n","category":"type"},{"location":"API/#SecondQuantizedAlgebra.SingleSum","page":"API","title":"SecondQuantizedAlgebra.SingleSum","text":"SingleSum <: QTerm\n\nDefines a symbolic summation over a term, using one Index entity.\n\nFields:\n\nterm: A multiplication of q-number terms. When the multiplication contains any IndexedOperator with the same index as the summation-index, a symbolic sum will be created.\nsum_index: The index, for which the summation will go over.\nnonequalindices: (optional) A vector of indices, for which the summation-index can not be equal with.\n\n\n\n\n\n","category":"type"},{"location":"API/#SecondQuantizedAlgebra.DoubleSum","page":"API","title":"SecondQuantizedAlgebra.DoubleSum","text":"DoubleSum <: QTerm\n\nDefines a symbolic summation over another SingleSum, using one Index entity. This corresponds to a double-summation over a multiplication of terms.\n\nFields:\n\ninnerSum: A SingleSum entity.\nsum_index: The index, for which the (outer) summation will go over.\nNEI: (optional) A vector of indices, for which the (outer) summation-index can not be equal with.\n\n\n\n\n\n","category":"type"},{"location":"API/#SecondQuantizedAlgebra.change_index","page":"API","title":"SecondQuantizedAlgebra.change_index","text":"change_index(term,from::Index,to::Index)\n\nExchanges all occurring indices inside the given term, that are equal to the from to the to index.\n\nExamples\n\nchange_index(σⱼ²¹,j,i) = σᵢ²¹\n\nchange_index(σⱼ²¹ * σᵢ¹²,j,i) = σᵢ²²\n\n\n\n\n\n","category":"function"},{"location":"API/#SecondQuantizedAlgebra.insert_index","page":"API","title":"SecondQuantizedAlgebra.insert_index","text":"insert_index(term,ind::Index,value::Int)\n\nFunction, that inserts an integer value for a index in a specified term. This function creates Numbered- Variables/Operators/Sums upon calls.\n\nExamples\n\ninsert_index(σⱼ²¹,j,1) = σ₁²¹\n\n\n\n\n\n","category":"function"},{"location":"API/#SecondQuantizedAlgebra.SpecialIndexedTerm","page":"API","title":"SecondQuantizedAlgebra.SpecialIndexedTerm","text":"SpecialIndexedTerm <: QTerm\n\nA multiplication of IndexedOperator entities, with special constraint on the index-values. For example σᵢ²² * σⱼ²² with the constraint i ≠ j\n\nFields:\n\nterm: A multiplication of q-number terms.\nindexMapping: A Vector of Index tuples, specifying the constraints for the term. Each Tuple is considered to one constraint. e.g: (i,j) -> i ≠ j\n\n\n\n\n\n","category":"type"},{"location":"API/#SecondQuantizedAlgebra.reorder","page":"API","title":"SecondQuantizedAlgebra.reorder","text":"reorder(param,indexMapping)\n\nReorders a given term (param) regarding to a given indexMapping, which specifies, which Index entities can not be equal inside the given term. reorder() creates a SpecialIndexedTerm as a result.\n\nExamples\n\nreorder(σⱼ²¹ * σᵢ²¹,[(i,j)]) = σᵢ²¹ * σⱼ²¹\n\nreorder(σⱼ²¹ * σᵢ²¹ * σⱼ¹²,[(i,j)]) = σᵢ²¹ * σⱼ²²\n\n\n\n\n\n","category":"function"},{"location":"API/#SecondQuantizedAlgebra.IndexedAverageSum","page":"API","title":"SecondQuantizedAlgebra.IndexedAverageSum","text":"IndexedAverageSum <: CNumber\n\nDefines a symbolic summation over an average, or a multiplication of several averages, using one Index entity.\n\nFields:\n\nterm: A multiplication of average terms.\nsum_index: The index, for which the summation will go over.\nnonequalindices: (optional) A vector of indices, for which the summation-index can not be equal with.\n\n\n\n\n\n","category":"type"},{"location":"API/#SecondQuantizedAlgebra.IndexedAverageDoubleSum","page":"API","title":"SecondQuantizedAlgebra.IndexedAverageDoubleSum","text":"IndexedAverageDoubleSum <: CNumber\n\nDefines a symbolic summation over an IndexedAverageSum, using a Index entity. This schematically represent a double-sum over a multiplication of averages.\n\nFields:\n\ninnerSum: An IndexedAverageSum entity.\nsum_index: The index, for which the (outer) summation will go over.\nnonequalindices: (optional) A vector of indices, for which the (outer) summation-index can not be equal with.\n\n\n\n\n\n","category":"type"},{"location":"API/#SecondQuantizedAlgebra.NumberedOperator","page":"API","title":"SecondQuantizedAlgebra.NumberedOperator","text":"NumberedOperator <: QSym\n\nDefines an operator, associated with a Number. Commutator-relations are calculated using these numbers, as a sort of a specific index-value.\n\nFields:\n\nop: An Operator, either a Transition, a Destroy or a Create can be defined.\nnumb: An Integer Number.\n\n\n\n\n\n","category":"type"}]
}
